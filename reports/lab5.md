### 简单总结你实现的功能:
-  我就是新建一个detector结构存题目描述的数据结构, 再直接按题目描述的流程为它impl检测算法. 在相应系统调用处更新这个结构, 并检测死锁.
- 完成时间3天左右.
### 问答题
1. 
- 需要回收的资源: 内核栈, 用户栈, 上下文, id, 互斥锁, 信号量等
- 引用位置: `suspend_current_and_run_next`, `block_current_and_run_next`, `exit_current_and_run_next`, `sys_waittid`, `lock`, `unlock`等函数.
其中只有`exit_current_and_run_next`和`sys_waittid`会回收, 因为只有这两种有线程结束需要回收的情况.

2. 
- 第一种情况`unlock`把锁打开再将`waking_task`唤醒. 第二种是不开锁, 直接把睡眠任务唤醒, 等没有等待任务时才开锁.
第一种情况可能的问题是, 打开锁和唤醒任务有一段间隙, 期间锁是开着的, 如果有其他任务拿锁, 可能会引发竞争;而第二中就不会这样.


### 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

        无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

        无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

### Option
- 这个实验遇到奇怪问题了, 在引言那里开始就跑不了哲学家吃饭问题, 发现是卡在sleep那里, 之后更发现有`sleep_blocking`的测试用例都会一睡不起, 卡住在sleep那里导致timeout过不了. 苦苦查找原因未果后重装环境(gettime, sbi等都没问题), 把qemu9换成了qemu7, 才没有了这个奇怪问题(据说有的人用qemu9又没问题), 哭了.
