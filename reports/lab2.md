### 简单总结你实现的功能:
- 重写sys_get_time & sys_task_info
    - 这个困扰我一段时间, 后来看到了`translate_byte_buffer`这个函数, 直接用传进来的指针获得内存数组, 再装好信息后一个一个字节硬填进去就过了 *(没有做目标对应内存分别在两个页表里的情况也过了QAQ)*

- mmap & munmap
    - 这两个我的实现就是先在系统调用函数对参数做些基本检查处理和转换, 之后再转交给`TASKMANAGER`那边进行真正的map和unmap.
    - 在`TASKMANAGER`中, 再调出当前任务的memory_set, 根据地址检测mmap或munmap操作是否合法, 合法后再用地址新建MapArea传给memory_set去map或unmap它里面的page_tale.<br>(我发现只要map或者unmap就可以过测试用例了, 而不需要把MapArea加入MemorySet的areas里, 所以为了方便就不对area进行操作了 XD)

### 问答题
1.
    - 组成: <br>
        | Reserved | Physical Page Number | RSW | D | A | G | U | X | W | R | V |<br> Reserved保留位10位, 物理号44位, RSW保留位2位, 剩下低8位为标志位
    - 标志位用来描述当前页表项, V表示标志位是否合法, R/W/X表示标志位读/写/取权限, U表示用户特权级访问权限, G表示全局是否可见, A表示页表项对应虚拟页面是否被访问过, D表示页表项对应虚拟页面是否被修改过

<br>

2.
    - StoreFault, StorePageFault, LoadFault, LoadPageFault   
    - 发生缺页时, 一些重要寄存器信息:
        - scause存储了异常原因.
        - stval存储了导致缺页的虚拟地址.
        - sstatus储存了发生trap之前的特权级信息.
        - sscratch储存了用户栈栈顶.
        - sepc储存了下一步指令位置.

    - 好处
        1. 节省内存, Lazy策略按需加载, 没有必要就不加载, 合理利用资源.
        2. 提高了程序启动速度, 不用等待所有数据都加载完
    - 数量级
        - 大约几十兆
    - 实现lazy
        - 先不加载, 等到缺页时再尝试在`trap_handler`那里加载内存
    - 页面失效
        - 此时PTE上的V位为0

<br>

3.
    - 修改satp寄存器即可
    - 把PTE里的U位置0即可
    - 机制简单, 速度快
    - 双页表下, 当发生用户态和内核态切换或进程切换时需要更换页表. 单页表操作系统, 可以在发生上下文切换时更换页表.


### 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

        无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

        训练营群友的聊天信息(带来了一些思路)

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

### Option
