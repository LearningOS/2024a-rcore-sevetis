### 简单总结你实现的功能:

##### (我能实现什么功能... 不就是题目要我实现的功能吗?)
- 首先, 题目要求实现一个系统调用来获取当前任务信息.<br>
首先看系统调用那里, 发现新系统调用已经搭好架子了.<br>
再看`任务信息`, 它包括:
    - status
    - syscall_times
    - time

-   想获得`time`非常简单, 直接调用已有函数就行了.
-   `status`也简单, 在impl TaskManager里加一个函数, 获取当前运行中任务的状态(??).<br>
再在外面加pub函数返回全局变量TASK_MANAGER调用刚才新增的函数返回的值.<br>
-   `syscall_times`要多写点东西, 仔细一看它是一个500个u32的数组(是不是太浪费了QAQ).<br>
不管了, 那我给每一个任务控制块都加一个这样的数组. 然后再给TaskManager加一个函数, 传一个数字进去(系统调用ID), <br>它就会给当前运行中的任务的任务控制块里的数组在以系统调用ID为下标的位置加一. <br>最后我在syscall函数那里使用这个函数, 每次syscall被调用, 就以syscall_id为参数调用这个函数, 这样就记录下了任务系统调用的次数.<br>最最后再像`status`那里加函数让外界获取这些信息即可.

- 最后再在sys_task_info壳子那里调用刚才的函数, 填上TaskInfo即可.


### 问答题

- 1.
    - ch2b_bad_address:
        - 报错:[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003a4, kernel killed it.<br>
        这个程序试图在0x00那里写东西, 然后看起来操作系统抱怨这个程序bad addr后就把它杀掉了.
    - ch2_bad_instructions:
        - 报错:[kernel] IllegalInstruction in application, kernel killed it.<br>
        这个程序直接运行sret, 这是S级用来回到U级的, 内核直接报错非法指令.
    - ch2_bad_register:
        - 报错:[kernel] IllegalInstruction in application, kernel killed it.<br>
        这个程序是想把sstatus寄存器的信息读出来, 但被报错非法指令了, 我不是太明白.:
    - sbi及其版本:
    ```bash
    [rustsbi] RustSBI version 0.2.2, adapting to RISC-V SBI v1.0.0
    ```

- 2.
    - 1.
        `a0`在约定中是函数返回值储存的地方.<br>
        而进入__restore之前的被调用的函数是`trap_handler`, 它把传给它的参数作为返回值返回了.<br>
        而它的参数是__alltraps存到a0给它的, a0存的是内核栈栈顶, 在里面存着32个通用寄存器和sstatus, sepc寄存器.

        **__restore使用的两种情景:**
            -   i. 发生系统调用, 陷入内核态后返回时恢复上下文用`__restore`.
            -   ii. 操作系统在某种特殊情况下(系统初始化完成, 处理完出错应用程序, 某个应用程序结束), 需要从S级降到U级, 可以复用`__restore`来实现.

    - 2.
        处理了3个特殊寄存器: sstatus, sepc, sscratch.它们储存了进入用户态所需的信息:
        - sstatus储存了发生trap之前的特权级信息.
        - sscratch储存了用户栈栈顶.
        - sepc储存了下一步指令位置.

    - 3.
        x2就是sp, 它现在指向存着上下文的内核栈, 先要把信息取出来才能改动sp.
        x4是线程指针, 它一般不会被我们用到, 所以跳过了.

    - 4.
        这条指令交换了sp和sscratch的内容, 指令之后, sp指向用户栈, sscratch指向内核栈.

    - 5.
        sret指令, 它会完成下面功能来回到用户态:
            - 根据sstatus寄存器的信息重新设置cpu当前特权级.
            - 让cpu跳转到sepc寄存器中的指令地址, 继续指向.

    - 6.
        如第4问, 交换两个寄存器的内容, 不过交换之后sp指向内核栈, sscratch指向用户栈.

    - 7.
        call trap_handler

     
### 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

        无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

        无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
