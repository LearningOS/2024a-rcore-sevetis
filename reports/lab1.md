### 简单总结你实现的功能:

##### (我能实现什么功能... 不就是题目要我实现的功能吗?)
- 首先, 题目要求实现一个系统调用来获取当前任务信息.<br>
首先看系统调用那里, 发现新系统调用已经搭好架子了.<br>
再看`任务信息`, 它包括:
    - status
    - syscall_times
    - time

    -   想获得`time`非常简单, 直接调用已有函数就行了.
    -   `status`简单, 在impl TaskManager里加一个函数, 获取当前运行中任务的状态(??).<br>
再在外面加pub函数返回全局变量TASK_MANAGER调用刚才新增的函数返回的值.<br>
    -   `syscall_times`要多写点东西, 仔细一看它是一个500个u32的数组(是不是太浪费了QAQ).<br>
不管了, 那我给每一个任务控制块都加一个这样的数组. 然后再给TaskManager加一个函数, 传一个数字进去(系统调用ID), <br>它就会给当前运行中的任务的任务控制块里的数组在以系统调用ID为下标的位置加一. <br>最后我在syscall函数那里使用这个函数, 每次syscall被调用, 就以syscall_id为参数调用这个函数, 这样就记录下了任务系统调用的次数.<br>最最后再像`status`那里加函数让外界获取这些信息即可.

- 最后再在sys_task_info壳子那里调用刚才的函数, 填上TaskInfo即可.


### 问答题

- 1.
    - 11

- 2.
    - 1.
        `a0`在约定中是函数返回值储存的地方.<br>
        而进入__restore之前的被调用的函数是`trap_handler`, 它把传给它的参数作为返回值返回了.<br>
        而它的参数是__alltraps存到a0给它的, a0存的是内核栈栈顶, 在里面存着32个通用寄存器和sstatus, sepc寄存器.

        **__restore使用的两种情景:**
            -   i. 发生系统调用, 陷入内核态后返回时恢复上下文用`__restore`.
            -   ii. 操作系统在某种特殊情况下(系统初始化完成, 处理完出错应用程序, 某个应用程序结束), 需要从S级降到U级, 可以复用`__restore`来实现.

    - 2.
        处理了3个特殊寄存器: sstatus, sepc, sscratch.它们储存了进入用户态所需的信息:
        - sstatus储存了发生trap之前的特权级信息.
        - sscratch储存了用户栈栈顶.
        - sepc储存了下一步指令位置.

    - 3.
        x2就是sp, 它现在指向存着上下文的内核栈, 先要把信息取出来才能改动sp.
        x4是线程指针, 它一般不会被我们用到, 所以跳过了.

    - 4.
        这条指令交换了sp和sscratch的内容, 指令之后, sp指向用户栈, sscratch指向内核栈.

    - 5.
        sret指令, 它会完成下面功能来回到用户态:
            - 根据sstatus寄存器的信息重新设置cpu当前特权级.
            - 让cpu跳转到sepc寄存器中的指令地址, 继续指向.

    - 6.
        如第4问, 交换两个寄存器的内容, 不过交换之后sp指向内核栈, sscratch指向用户栈.

    - 7.
        call trap_handler
        
